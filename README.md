# hackit-hackathon - חברי הקבוצה: בר פישלביץ, לינוי כהן, רותם רונן
Group project for timing attacks: Flask website with a delayed password check plus a Python script for hacking the website and for hacking other websites.

## אלגוריתם ההגנה
בכל שעה נבחרת אות אקראית חדשה, והיא משמשת כאות המפתח בסיסמא שהמשתמש שולח.
כאשר הסיסמא שנשלחת מכילה את האות הזאת לפחות 11 פעמים, המערכת נכנסת למסלול
בדיקה מיוחד שבו הדיליי מאפשר לקבל מידע נוסף.
במסלול זה האלגוריתם בודק רק את האות האחת ששונה מאות המפתח של אותה שעה.
הזמן במסלול זה יהיה מינימלי כאשר התו נכון (נשמור על דיליי גבוה כדי להאט את הפריצה, במטרה שגם אות המפתח תשתנה והפורץ יצטרך למצוא אותה מחדש).
במסלול בדיקה השני (אם זה לא מתקיים) יש דיליי רנדומלי גבוה שמטרתו להאט את הפריצה ולבלבל את הפורץ.
בנוסף, הוספנו אלמנט מבלבל כך שאם הסיסמא קטנה מאורך 5 אז יהיה דיליי קטן בקצת (דבר זה נועד לבילבול הפורץ בעת מציאת אורך הסיסמא).

אלגוריתם זה יעמוד בפני פריצה שבודקת תווים במיקומים שונים, כיוון שבכדי לפרוץ לאתר שלנו צריך להכנס למסלול בדיקה מיוחד.
אלגוריתם זה גם יעמוד בפריצה שתבדוק את אורך הסיסמא שכן הוספנו אלמנט שמבלבל את הפורץ לגבי אורך הסיסמא.
בנוסף, אלגוריתם זה מונע מהפורץ לערוך פריצה ממושכת, כיוון שאות המפתח משתנה כל שעה מה שיגרות לפורץ להתחיל את ההרצה מחדש.

## הפריצה לאתר שלנו
כדי לפרוץ לאתר שלנו נבדוק מהי אות המפתח ולאחר מכן נעבור אות אות במיקום הנוכחי עד שנמצא את האות
עם הזמן המינימלי, שהיא האות הנכונה במיקום הזה. אם השעה מתחלפת נמצא מחדש את אות המפתח ונמשיך בבדיקה.
במקרה ואין אות עם זמן קטן בהרבה מהשאר, נבדוק את 4 האותיות עם הזמן הקטן ביותר שוב.

נמדוד את הזמן 8 פעמים בשביל למצוא את הזמן האמין ביותר.
כדי לסנן את ההפרעות של הרשת במדידת הזמנים נשתמש באלגוריתם MAD (Median Absolute Deviation):
האלגוריתם מחשב תחילה את החציון של זמני התגובה, ולאחר מכן את החציון של המרחקים המוחלטים מהחציון.
מדידות שסוטות מעבר לסף מוגדר נחשבות כרעש ומוסרות, וההחלטה על האות הנכונה מתקבלת לפי הממוצע של המדידות המסוננות.


## הפריצה לשרתים של קבוצות אחרות
אנחנו מדדנו את הזמנים של כל תו בכל מיקום בסיסמא וגם מדדנו מקרים שבהם התו מופיע ברצף עד למיקום מסויים, לדוגמא:
a
aa
aaa
...
כך קיבלנו מידע על האלגוריתם שלפיו השרת קובע את הדיליי ויכולנו למצוא תווים שמקבלים דיליי שונה מהשאר.
כך מצאנו את הסיסמא של שתי קבוצות בתחרות.
הנחנו כי אורך הסיסמא הוא 6, שכן הוא האורך המקסימלי.
מדדנו את הזמן 8 פעמים בשביל אמינות של התוצאה.

## To install requirements:
pip install -r requirements.txt

## If you clone the repo, you can use the exiting venv:
In cmd: venv\Scripts\activate

## הרצה:
כדי לפרוץ לאתר שלנו יש להריץ את הקובץ hackit_me.py כאשר התקנתם את הספריות הנדרשות.
כדי להשיג מידע על שרתים אחרים ולנסות לפרוץ אותם יש להריץ את הקובץ hackit_others.py עם הקישור לשרת המתאים.

# ניתוח יעילות
## כמה ניסיונות סיסמה היו דרושים תיאורטית ב-brute force?
אם אורך הסיסמה הוא n וכמות התווים היא k אז ידרשו: k^n ניסיונות.
עבור 62 תווים ואורך 6 ידרשו כ 56 מיליארד ניסיונות.

## כמה ניסיונות השתמשנו בפועל?
בפועל, בדקנו כל תו בנפרד לכל מיקום, ולכן מספר הניסיונות היה בקירוב: 8*k*n
כ 3000.

## מה היחס בין מספר הניסיונות?
היחס בין brute force לבין Timing Attack הוא עצום — ירידה ממיליארדי ניסיונות לאלפים בודדים בלבד, כלומר חיסכון של מספר סדרי גודל.
היחס הזה בשבר כמעט אפס 3/56000000

## כמה זמן חסכתם בגישת Timing Attack?
במקום אלפי שנים (בקירוב 5500) זה לקח כמה שעות (כ-4).